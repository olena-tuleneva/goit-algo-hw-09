# goit-algo-hw-09
Реалізовано два підходи: жадібний алгоритм та динамічне програмування. 
Обидва методи знаходять розв'язок, але мають суттєві відмінності в продуктивності:
1. Жадібний алгоритм (find_coins_greedy).
Принцип роботи: на кожному кроці обирає монету найбільшого номіналу.
Складність: часова — O(k), просторова — O(1) (k — кількість номіналів).
Переваги: швидкість і мінімальне споживання пам'яті, ефективний для великих сум.
Недоліки: оптимальність лише для "канонічних" систем монет. Для довільних наборів (наприклад, [1, 3, 4]) може знайти не мінімальну кількість монет.
2. Алгоритм динамічного програмування (find_min_coins).
Принцип роботи: будує таблицю оптимальних розв'язків для всіх проміжних сум.
Складність: часова — O(n*k), просторова — O(n) (n — сума, k — кількість номіналів).
Переваги: завжди знаходить глобально мінімальну кількість монет для будь-якого набору номіналів.
Недоліки: при великих сумах суттєво зростають витрати пам'яті та час виконання.

Висновок:
Для фіксованої та канонічної системи монет жадібний алгоритм є оптимальним вибором завдяки своїй простоті, високій швидкодії та мінімальним витратам ресурсів. 
Алгоритм динамічного програмування доцільно використовувати у випадках, коли система номіналів може змінюватися або не гарантує коректної роботи жадібного підходу.
У даному завданні обидва алгоритми формують однакове оптимальне рішення, однак жадібний алгоритм є значно ефективнішим з практичної точки зору.